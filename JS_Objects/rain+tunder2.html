
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Cinematic Rain Storm</title>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family: system-ui, sans-serif; }
  canvas { display:block; }
  #loader {
    position: fixed; inset:0;
    background:#050505;
    display:flex;
    align-items:center;
    justify-content:center;
    color:#4a88ff;
    font-size:1.4rem;
    z-index:10;
  }
</style>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<div id="loader">Initializing Storm...</div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

const CONFIG = {
  rainCount: 16000,
  wind: 0.6,
  lightningChance: 0.12,
  bgColor: 0x020208,
  fogColor: 0x050515
};

let scene, camera, renderer, composer;
let rain, cloudGroup;
let ambientLight, flash;
let clock = new THREE.Clock();
let mouse = {x:0,y:0};
let shake = 0;

init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(CONFIG.bgColor);
  scene.fog = new THREE.FogExp2(CONFIG.fogColor, 0.0015);

  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 1000);
  camera.position.set(0, 20, 100);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));

  const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.3, 0.4, 0.85);
  composer.addPass(bloom);

  ambientLight = new THREE.AmbientLight(0x111122, 0.8);
  scene.add(ambientLight);

  flash = new THREE.PointLight(0x88aaff, 0, 600);
  scene.add(flash);

  createClouds();
  createRain();

  window.addEventListener('resize', onResize);
  document.addEventListener('mousemove', e => {
    mouse.x = (e.clientX / innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  });

  document.getElementById('loader').style.display = 'none';
}

function createClouds(){
  cloudGroup = new THREE.Group();

  const cloudTex = createCloudTexture();
  const cloudMat = new THREE.MeshBasicMaterial({
    map: cloudTex,
    transparent: true,
    opacity: 0.6,
    depthWrite: false
  });

  const cloudGeo = new THREE.PlaneGeometry(400, 200);

  for(let i=0; i<15; i++){
    const cloud = new THREE.Mesh(cloudGeo, cloudMat);
    cloud.position.set(
      Math.random()*800 - 400,
      Math.random()*120 + 40,
      Math.random()*-300 - 50
    );
    cloud.rotation.z = Math.random() * Math.PI;
    cloud.scale.set(
      Math.random()*1.5 + 1,
      Math.random()*1.5 + 1,
      1
    );
    cloudGroup.add(cloud);
  }

  scene.add(cloudGroup);
}

function createCloudTexture(){
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');

  const grad = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
  grad.addColorStop(0, 'rgba(255,255,255,1)');
  grad.addColorStop(0.4, 'rgba(200,200,255,0.35)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,256,256);

  return new THREE.CanvasTexture(canvas);
}

function createRain(){
  const positions = [];
  const speeds = [];

  for(let i=0; i<CONFIG.rainCount; i++){
    positions.push(
      Math.random()*400 - 200,
      Math.random()*500 - 250,
      Math.random()*400 - 200
    );
    speeds.push(Math.random()*30 + 30);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geo.setAttribute('speed', new THREE.Float32BufferAttribute(speeds, 1));

  const mat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uWind: { value: CONFIG.wind }
    },
    vertexShader: `
      attribute float speed;
      uniform float uTime;
      uniform float uWind;
      varying float vAlpha;

      void main(){
        vec3 pos = position;
        float fall = speed * uTime;

        pos.y = mod(pos.y - fall, 500.0) - 250.0;
        pos.x += uWind * fall * 0.1;

        vec4 mv = modelViewMatrix * vec4(pos,1.0);
        gl_PointSize = 2.0 * (300.0 / -mv.z);

        vAlpha = smoothstep(250.0,200.0,pos.y) * smoothstep(-250.0,-200.0,pos.y);
        gl_Position = projectionMatrix * mv;
      }
    `,
    fragmentShader: `
      varying float vAlpha;

      void main(){
        float d = length(gl_PointCoord - vec2(0.5));
        float alpha = smoothstep(0.5, 0.0, d);
        gl_FragColor = vec4(0.8, 0.9, 1.0, alpha * vAlpha);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });

  rain = new THREE.Points(geo, mat);
  scene.add(rain);
}

let lightningTimer = 0;

function updateLightning(dt){
  lightningTimer -= dt;
  if(lightningTimer <= 0 && Math.random() < CONFIG.lightningChance * 0.002){
    lightningTimer = 0.25 + Math.random()*0.4;
    flash.power = 400 + Math.random()*800;
    ambientLight.intensity = 3;
    shake = 0.4;
    scene.background.setHex(0x334477);
  } else {
    scene.background.lerp(new THREE.Color(CONFIG.bgColor), 0.05);
  }

  flash.power *= 0.85;
  ambientLight.intensity = THREE.MathUtils.lerp(ambientLight.intensity, 0.8, 0.08);
}

function animate(){
  requestAnimationFrame(animate);

  const dt = clock.getDelta();
  const t = clock.getElapsedTime();

  rain.material.uniforms.uTime.value = t * 10;

  cloudGroup.rotation.y += 0.0005;

  updateLightning(dt);

  camera.position.x += mouse.x * 0.05;
  camera.position.x += (Math.random()-0.5)*shake;
  camera.position.y += (Math.random()-0.5)*shake;
  shake *= 0.9;

  composer.render();
}

function onResize(){
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
}
</script>
</body>
</html>
